// Copyright (c) 2014-2015 K Team. All Rights Reserved.
package org.kframework.backend.java.symbolic;

import org.kframework.backend.java.kil.*;
import org.kframework.backend.java.kil.CellCollection.Cell;
import org.kframework.backend.java.rewritemachine.KAbstractRewriteMachine;
import org.kframework.backend.java.rewritemachine.MatchingInstruction;
import org.kframework.backend.java.rewritemachine.RHSInstruction;
import org.kframework.backend.java.util.Profiler;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.Map;


/**
 * K abstract rewrite machine. Given a subject term and a rewrite rule, the
 * rewrite machine attempts to apply the rewrite rule by executing the
 * instructions generated by the rewrite rule.
 *
 * @author YilongL
 *
 */
public class AbstractKMachine {

    private final ConstrainedTerm subject;
    private final List<MatchingInstruction> instructions;
    private final Map<CellLabel, Term> cells;

    // program counter
    private int pc = 1;
    private boolean success = true;
    private ConjunctiveFormula substitution;

    private final SymbolicUnifier unifier;

    private final TermContext context;

    private AbstractKMachine(
            ConstrainedTerm subject,
            List<MatchingInstruction> instructions,
            Map<CellLabel, Term> cells,
            TermContext context) {
        this.subject = subject;
        this.instructions = instructions;
        this.cells = cells;
        this.substitution = ConjunctiveFormula.of(context);
        this.unifier = new SymbolicUnifier(context);
        this.context = context;
    }

    public static ConjunctiveFormula unify(
            ConstrainedTerm subject,
            List<MatchingInstruction> instructions,
            Map<CellLabel, Term> cells,
            TermContext context) {
        return new AbstractKMachine(subject, instructions, cells, context).unify();
    }

    public static CellCollection apply(
            CellCollection subject,
            Substitution<Variable, Term> substitution,
            Rule rule,
            TermContext context) {
        return new RHSConstructor(substitution, rule, context).transform(subject);
    }

    private ConjunctiveFormula unify() {
        match(DataStructures.getCellEntry(subject.term()));
        if (success) {
            return substitution;
        } else {
            return null;
        }
    }

    private void match(CellCollection.Cell cell) {
        if (isReadCell(cell.cellLabel())) {
            // perform matching under read cell
            Profiler.startTimer(Profiler.PATTERN_MATCH_TIMER);
            if (unifier.symbolicUnify(cell.content(), getReadCellLHS(cell.cellLabel()), substitution)) {
                substitution = unifier.constraint();
            } else {
                success = false;
            }
            Profiler.stopTimer(Profiler.PATTERN_MATCH_TIMER);

            if (!success) {
                return;
            }
        }

        while (true) {
            MatchingInstruction instruction = nextInstruction();
            if (instruction == MatchingInstruction.UP) {
                return;
            }

            if (instruction == MatchingInstruction.CHOICE) {
                assert cell.content() instanceof CellCollection && ((CellCollection) cell.content()).isConcreteCollection();
                instruction = nextInstruction();

                int successPC = -1; // pgm counter on success
                PersistentUniqueList<ConjunctiveFormula> substitutions = PersistentUniqueList.empty();
                for (CellCollection.Cell subCell : getSubCellsByLabel(cell, instruction.cellLabel())) {
                    int stashedPC = pc; // pgm counter before AC-matching
                    ConjunctiveFormula stashedSubstitution = substitution;
                    success = true;
                    match(subCell);
                    if (success) {
                        substitution = substitution.add(
                                Rule.getChoiceVariableForCell(instruction.cellLabel()),
                                CellCollection.singleton(
                                        subCell.cellLabel(),
                                        subCell.content(),
                                        context.definition()));
                        substitutions = substitutions.plus(substitution);
                        assert successPC == -1 || successPC == pc;
                        successPC = pc;
                    }
                    pc = stashedPC;
                    substitution = stashedSubstitution;
                }

                if (!substitutions.isEmpty()) {
                    if (substitutions.size() == 1) {
                        substitution = substitution.addAndSimplify(substitutions.get(0));
                        if (substitution.isFalse()) {
                            success = false;
                            return;
                        }
                    } else {
                        substitution = substitution.add(new DisjunctiveFormula(
                                substitutions,
                                context));
                    }
                    success = true;
                    pc = successPC;
                } else {
                    success = false;
                    return;
                }
            } else {
                assert instruction.type() == MatchingInstruction.Type.GOTO;
                List<CellCollection.Cell> cells = getSubCellsByLabel(cell, instruction.cellLabel());
                if (cells.size() != 1) {
                    success = false;
                    return;
                }
                match(cells.get(0));
                if (!success) {
                    return;
                }
            }
        }
    }

    private MatchingInstruction nextInstruction() {
        return instructions.get(pc++);
    }

    private boolean isReadCell(CellLabel cellLabel) {
        return cells.keySet().contains(cellLabel);
    }

    private Term getReadCellLHS(CellLabel cellLabel) {
        return cells.get(cellLabel);
    }

    private static List<Cell> getSubCellsByLabel(CellCollection.Cell cell, CellLabel label) {
        assert cell.content() instanceof CellCollection : "expected contents of cell " + cell.cellLabel() + " to be a CellCollection but found " + cell.content().getClass().getSimpleName();
        return ((CellCollection) cell.content()).cells().get(label);
    }


    private static class RHSConstructor extends CopyOnWriteTransformer {

        private final Substitution<Variable, Term> substitution;
        private final Rule rule;

        private RHSConstructor(Substitution<Variable, Term> substitution, Rule rule, TermContext context) {
            super(context);
            this.substitution = substitution;
            this.rule = rule;
        }

        @Override
        public CellCollection transform(CellCollection cellCollection) {
            boolean changed = false;
            CellCollection.Builder builder = CellCollection.builder(context.definition());
            for (CellCollection.Cell cell : cellCollection.cells().values()) {
                CellCollection selectedCell = (CellCollection) substitution.get(Rule.getChoiceVariableForCell(cell.cellLabel()));
                if (selectedCell != null && !cell.equals(selectedCell.cells().values().iterator().next())) {
                    builder.put(cell.cellLabel(), cell.content());
                } else if (isWriteCell(cell.cellLabel())) {
                    List<RHSInstruction> instructions = getWriteCellInstructions(cell.cellLabel());
                    builder.put(
                            cell.cellLabel(),
                            KAbstractRewriteMachine.construct(instructions, substitution, null, context, false));
                    changed = true;
                } else if (cell.content() instanceof CellCollection) {
                    CellCollection transformedContent = transform((CellCollection) cell.content());
                    builder.put(cell.cellLabel(), transformedContent);
                    changed = changed || cell.content() != transformedContent;
                } else {
                    builder.put(cell.cellLabel(), cell.content());
                }
            }
            return changed ? (CellCollection) builder.build() : cellCollection;
        }

        private boolean isWriteCell(CellLabel cellLabel) {
            return rule.rhsOfWriteCell().keySet().contains(cellLabel);
        }

        private List<RHSInstruction> getWriteCellInstructions(CellLabel cellLabel) {
            return rule.instructionsOfWriteCell().get(cellLabel);
        }
    }

}
