// Copyright (c) 2015 K Team. All Rights Reserved.
package org.kframework.backend.func;

import com.google.inject.Inject;
import com.google.common.collect.Lists;
import com.google.common.base.Stopwatch;

import java.io.IOException;
import java.io.File;
import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.function.Function;
import java.util.concurrent.TimeUnit;
import scala.Tuple2;

import org.kframework.Rewriter;
import org.kframework.RewriterResult;
import org.kframework.attributes.Source;
import org.kframework.definition.Module;
import org.kframework.definition.Rule;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.KompileOptions;
import org.kframework.kore.K;
import org.kframework.kore.KVariable;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.BinaryLoader;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import org.kframework.utils.inject.DefinitionScoped;
import org.kframework.utils.koreparser.KoreParser;

import static org.kframework.kore.KORE.*;
import static org.kframework.backend.func.FuncUtil.*;

/**
 * Responsible for converting K for the functional backend at krun time
 *
 * @author Remy Goldschmidt
 */
@DefinitionScoped
public class FuncRewriter implements Function<Module, Rewriter> {
    private final KExceptionManager kem;
    private final CompiledDefinition def;
    private final KToFunc converter;
    private final ProcessBuilder processBuilder;
    private final Stopwatch timer = Stopwatch.createUnstarted();
    private static final String ocamlPackages = "zarith,str";
    private static final Source ocamlSrc = Source.apply("generated by OCaml output");

    private final File
        compileDirectory, compileOutFile, compileErrFile,
        runtimeDirectory, runtimeOutFile, runtimeErrFile,
        kompileDirectory, kompileDefFile, pgmSourceFile,
        runOutputFile,    runSubstFile;

    private final String runOutputPath, runSubstPath;

    private static final String
        compileDirectoryName, compileOutFileName,   compileErrFileName,
        runtimeDirectoryName, runtimeOutFileName,   runtimeErrFileName,
        binaryOutputFileName, kompileDirectoryName, kompileDefFileName,
        pgmSourceFileName,    runOutputFileName,    runSubstFileName;

    static {
        compileDirectoryName = ".";
        compileOutFileName   = "compile.out";
        compileErrFileName   = "compile.err";
        runtimeDirectoryName = ".";
        runtimeOutFileName   = "run.out";
        runtimeErrFileName   = "run.err";
        binaryOutputFileName = "./a.out";
        kompileDirectoryName = ".";
        kompileDefFileName   = "def.cmo";
        pgmSourceFileName    = "pgm.ml";
        runOutputFileName    = "run.out";
        runSubstFileName     = "run.subst";
    }

    // If you don't use ocamlfind, you will want to change this
    private static final String[] ocamlCmd = new String[]{
        "ocamlfind",
        "ocamlc",
        "-package",
        ocamlPackages,
        "-linkpkg",
        "-dllpath-all",
        "-g"
    };

    @Inject
    public FuncRewriter(KExceptionManager kem,
                        FileUtil files,
                        GlobalOptions globalOptions,
                        KompileOptions kompileOptions,
                        CompiledDefinition def,
                        InitializeDefinition init) {
        this.kem = kem;
        this.def = def;

        this.processBuilder = files.getProcessBuilder();

        this.converter = new KToFunc(def, kem, files,
                                     globalOptions, kompileOptions);

        this.compileDirectory = files.resolveTemp(compileDirectoryName);
        this.compileErrFile   = files.resolveTemp(compileErrFileName);
        this.compileOutFile   = files.resolveTemp(compileOutFileName);
        this.runtimeDirectory = files.resolveTemp(runtimeDirectoryName);
        this.runtimeErrFile   = files.resolveTemp(runtimeErrFileName);
        this.runtimeOutFile   = files.resolveTemp(runtimeOutFileName);

        this.kompileDirectory = files.resolveKompiled(kompileDirectoryName);
        this.kompileDefFile   = files.resolveKompiled(kompileDefFileName);

        this.pgmSourceFile    = files.resolveTemp(pgmSourceFileName);

        this.runOutputFile    = files.resolveTemp(runOutputFileName);
        this.runSubstFile     = files.resolveTemp(runSubstFileName);

        this.runOutputPath    = runOutputFile.getAbsolutePath();
        this.runSubstPath     = runSubstFile.getAbsolutePath();
    }

    @Override
    public Rewriter apply(Module module) {
        if(!module.equals(def.executionModule())) {
            nonExecutionModuleError();
        }

        return new Rewriter() {
            @Override
            public RewriterResult execute(K k, Optional<Integer> depth) {
                int d = depth.orElse(-1);
                return new RewriterResult(Optional.<Integer>empty(),
                                          executeOCaml(k, d).getE());
            }

            @Override
            public List<Map<KVariable, K>> match(K k, Rule rule) {
                return matchOCaml(k, rule).getM();
            }

            @Override
            public Tuple2<K, List<Map<KVariable, K>>>
                executeAndMatch(K k, Optional<Integer> depth, Rule rule) {
                RunResults r = executeAndMatchOCaml(k, depth.orElse(-1), rule);
                return Tuple2.apply(r.getE(), r.getM());
            }

            @Override
            public List<Map<KVariable, K>> search(K initialConfiguration,
                                                  Optional<Integer> depth,
                                                  Optional<Integer> bound,
                                                  Rule pattern) {
                throw new UnsupportedOperationException();
            }
        };
    }

    private RunResults executeOCaml(K k, int depth) {
        savePgm(generateExecuteOCaml(k, depth));
        compileAndRunOCaml();
        return readOCamlOutput(RunMode.EXECUTE);
    }

    private RunResults matchOCaml(K k, Rule rule) {
        savePgm(generateMatchOCaml(k, rule));
        compileAndRunOCaml();
        return readOCamlOutput(RunMode.MATCH);
    }

    private RunResults executeAndMatchOCaml(K k, int depth, Rule rule) {
        savePgm(generateExecuteAndMatchOCaml(k, depth, rule));
        compileAndRunOCaml();
        return readOCamlOutput(RunMode.BOTH);
    }

    private void savePgm(String ocaml) {
        FileUtil.save(pgmSourceFile, ocaml);
    }

    private String generateExecuteOCaml(K k, int depth) {
        return converter.execute(k, depth, runOutputPath);
    }

    private String generateMatchOCaml(K k, Rule rule) {
        return converter.match(k, rule, runOutputPath);
    }

    private String generateExecuteAndMatchOCaml(K k,
                                                int depth,
                                                Rule rule) {
        return converter.executeAndMatch(k, depth, rule,
                                         runOutputPath,
                                         runSubstPath);
    }

    private void compileAndRunOCaml() {
        compileOCaml();
        runOCaml();
    }

    private void compileOCaml() {
        try {
            Process p = startCompileProcess();

            int exit = p.waitFor();
            if(exit != 0) { compileFailedError(exit); }
        } catch(InterruptedException e) {
                compileInterruptedError(e);
        } catch(IOException e) {
            compileIOError(e);
        }
    }

    private void runOCaml() {
        try {
            Process p = startRuntimeProcess();

            int exit = p.waitFor();
            if(exit != 0) { runtimeFailedError(exit); }
        } catch(InterruptedException e) {
            runtimeInterruptedError(e);
        } catch(IOException e) {
            runtimeIOError(e);
        }
    }


    private RunResults readOCamlOutput(RunMode rm) {
        String output, subst;
        output = FileUtil.load(runOutputFile);
        subst  = rm == RunMode.EXECUTE ? "" : FileUtil.load(runSubstFile);
        List<Map<KVariable, K>> match;

        switch(rm) {
        case EXECUTE:
            return RunResults.newRunResults(parseExecuteOutput(output));
        case MATCH:
            return RunResults.newRunResults(parseMatchOutput(subst));
        case BOTH:
            return RunResults.newRunResults(parseExecuteOutput(output),
                                            parseMatchOutput(subst));
        default:
            assert false; // we should not get here
            return null;
        }
    }

    // TODO(remy):
    // There has to be a better way of doing this
    // i.e.: by pretty-printing it to XML that Java can parse automatically
    private List<Map<KVariable, K>> parseMatchOutput(String output) {
        String[] lines = output.split("\n");
        int count = Integer.parseInt(lines[0]);
        int line = 1;
        List<Map<KVariable, K>> list = newArrayList();
        for (int i = 1; i <= count; i++) {
            Map<KVariable, K> map = newHashMap();
            list.add(map);
            while(lines.length > line) {
                if (lines[line].equals("|")) {
                    line++;
                    break;
                }
                KVariable key = KVariable(lines[line]);
                K value = parseKORE(lines[line+1]);
                map.put(key, value);
                line += 2;
            }
        }
        return list;
    }

    private K parseExecuteOutput(String output) {
        return parseKORE(output);
    }

    private K parseKORE(String output) {
        return KoreParser.parse(output, Source.apply(runOutputPath));
    }

    private Process startRuntimeProcess() throws IOException {
        return startProcess(processBuilder,
                            runtimeDirectory,
                            runtimeErrFile,
                            runtimeOutFile,
                            getRuntimeCommandLine());
    }

    private Process startCompileProcess() throws IOException {
        return startProcess(processBuilder,
                            compileDirectory,
                            compileErrFile,
                            compileOutFile,
                            getCompileCommandLine());
    }

    private String[] getCompileCommandLine() {
        int pbListLength = ocamlCmd.length + 10; // padding
        List<String> pbList = Lists.newArrayListWithCapacity(pbListLength);

        pbList = FuncUtil.addMany(pbList, ocamlCmd);
        pbList.add("-I");
        pbList.add(kompileDirectory.getAbsolutePath());
        pbList.add(kompileDefFile.getAbsolutePath());
        pbList.add(pgmSourceFileName);

        outprintfln("OCaml krun command line: %s", pbList);

        return pbList.toArray(new String[pbList.size()]);
    }

    private String[] getRuntimeCommandLine() {
        return new String[]{ binaryOutputFileName };
    }

    private void nonExecutionModuleError() {
        throw kemCriticalErrorF("Invalid module specified for rewriting.\n" +
                                "Functional backend only supports rewriting\n" +
                                "over the definition's main module.");
    }

    private void compileFailedError(int exitCode) {
        errprintfln(FileUtil.load(compileErrFile));
        throw kemCriticalErrorF("Failed to compile program to OCaml.\n" +
                                "See output for error information.\n" +
                                "OCaml exit code: %d\n", exitCode);
    }

    private void runtimeFailedError(int exitCode) {
        errprintfln(FileUtil.load(runtimeErrFile));
        throw kemCriticalErrorF("Failed to execute program in OCaml.\n" +
                                "Rerun with --debug and examine the\n" +
                                "temporary directory for information\n" +
                                "Program exit code: %d\n", exitCode);
    }

    private void compileInterruptedError(InterruptedException e) {
        Thread.currentThread().interrupt();
        throw kemCriticalErrorF(e, "OCaml compile process interrupted.");
    }

    private void runtimeInterruptedError(InterruptedException e) {
        Thread.currentThread().interrupt();
        throw kemCriticalErrorF(e, "Generated OCaml code interrupted.");
    }

    private void compileIOError(IOException e) {
        throw kemCriticalErrorF(e, "Failed to run OCaml compiler: %s", e.getMessage());
    }

    private void runtimeIOError(IOException e) {
        throw kemCriticalErrorF(e, "Failed to run generated OCaml program: %s", e.getMessage());
    }

    private void resetAndStartTimer() {
        timer.reset();
        timer.start();
    }

    private void stopAndReportTimer(String format) {
        timer.stop();
        outprintfln(format, timer.elapsed(TimeUnit.SECONDS));
    }

    @DefinitionScoped
    public static class InitializeDefinition {
        private final DefinitionToFunc serialized;

        @Inject
        public InitializeDefinition(BinaryLoader loader, FileUtil files) {
            serialized = null;
//            serialized = loader.loadOrDie(DefinitionToFunc.class,
//                                          files.resolveKompiled("conv.bin"));
        }
    }

    private enum RunMode {
        EXECUTE, MATCH, BOTH;
    }

    private static class RunResults {
        private final Optional<K> resultE;
        private final Optional<List<Map<KVariable, K>>> resultM;

        public static RunResults newRunResults(K e) {
            return new RunResults(Optional.of(e), Optional.empty());
        }

        public static RunResults newRunResults(List<Map<KVariable, K>> m) {
            return new RunResults(Optional.empty(), Optional.of(m));
        }

        public static RunResults newRunResults(K e, List<Map<KVariable, K>> m) {
            return new RunResults(Optional.of(e), Optional.of(m));
        }

        private RunResults(Optional<K> resultE,
                           Optional<List<Map<KVariable, K>>> resultM) {
            this.resultE = resultE;
            this.resultM = resultM;
        }

        public K getE() {
            if(resultE.isPresent()) {
                return resultE.get();
            } else {
                throw kemCriticalErrorF("Called wrong accessor in RunResults");
            }
        }

        public List<Map<KVariable, K>> getM() {
            if(resultM.isPresent()) {
                return resultM.get();
            } else {
                throw kemCriticalErrorF("Called wrong accessor in RunResults");
            }
        }
    }
}
