// Copyright (c) 2015 K Team. All Rights Reserved.
package org.kframework.backend.func;

import com.google.inject.Inject;
import com.google.common.collect.Lists;
import com.google.common.base.Stopwatch;

import java.io.IOException;
import java.io.File;
import java.util.List;
import java.util.Arrays;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.BiFunction;
import java.util.concurrent.TimeUnit;

import org.kframework.Rewriter;
import org.kframework.attributes.Source;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.KompileOptions;
import org.kframework.kore.K;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import org.kframework.utils.inject.DefinitionScoped;

import static org.kframework.backend.func.FuncUtil.*;

/**
 * Responsible for converting K for the functional backend at krun time
 *
 * @author Remy Goldschmidt
 */
@DefinitionScoped
public class FuncRewriter implements Function<Module, Rewriter> {
    private final KExceptionManager kem;
    private final CompiledDefinition def;
    private final DefinitionToFunc converter;
    private final ProcessBuilder processBuilder;
    private final Stopwatch timer = Stopwatch.createUnstarted();
    private static final String ocamlPackages = "zarith,str";
    private static final Source ocamlSrc = Source.apply("generated by OCaml output");

    private final File
        compileDirectory, compileOutFile, compileErrFile,
        runtimeDirectory, runtimeOutFile, runtimeErrFile,
        kompileDirectory, kompileDefFile, pgmSourceFile;

    private static final String
        compileDirectoryName, compileOutFileName, compileErrFileName,
        runtimeDirectoryName, runtimeOutFileName, runtimeErrFileName,
        binaryOutputFileName, kompileDirectoryName, kompileDefFileName,
        pgmSourceFileName;

    static {
        compileDirectoryName = ".";
        compileOutFileName   = "compile.out";
        compileErrFileName   = "compile.err";
        runtimeDirectoryName = ".";
        runtimeOutFileName   = "run.out";
        runtimeErrFileName   = "run.err";
        binaryOutputFileName = "./a.out";
        kompileDirectoryName = ".";
        kompileDefFileName   = "def.cmo";
        pgmSourceFileName    = "pgm.ml";
    }

    // If you don't use ocamlfind, you will want to change this
    private static final String[] ocamlCmd = new String[]{
        "ocamlfind",
        "ocamlc",
        "-package",
        ocamlPackages,
        "-linkpkg",
        "-dllpath-all",
        "-g"
    };

    @Inject
    public FuncRewriter(KExceptionManager kem,
                        FileUtil files,
                        GlobalOptions globalOptions,
                        KompileOptions kompileOptions,
                        CompiledDefinition def) {
        this.kem = kem;
        this.def = def;

        this.processBuilder = files.getProcessBuilder();

        this.converter = new DefinitionToFunc(kem, files,
                                              globalOptions, kompileOptions);

        this.compileDirectory = files.resolveTemp(compileDirectoryName);
        this.compileErrFile   = files.resolveTemp(compileErrFileName);
        this.compileOutFile   = files.resolveTemp(compileOutFileName);
        this.runtimeDirectory = files.resolveTemp(runtimeDirectoryName);
        this.runtimeErrFile   = files.resolveTemp(runtimeErrFileName);
        this.runtimeOutFile   = files.resolveTemp(runtimeOutFileName);

        this.kompileDirectory = files.resolveKompiled(kompileDirectoryName);
        this.kompileDefFile   = files.resolveKompiled(kompileDefFileName);

        this.pgmSourceFile    = files.resolveTemp(pgmSourceFileName);

        converter.convert(def);
    }

    @Override
    public Rewriter apply(Module module) {
        if(!module.equals(def.executionModule())) {
            nonExecutionModuleError();
        }

        return new Rewriter() {
            @Override
            public K execute(K k, Optional<Integer> depth) {
                return executeOCaml(k, depth);
            }
        };
    }

    private K executeOCaml(K k, Optional<Integer> depth) {
        timer.start();
        generateOCaml(k, depth);
        stopAndReportTimer("Time required to generate krun OCaml: %d s");
        resetAndStartTimer();
        compileOCaml();
        stopAndReportTimer("Time required to compile krun OCaml: %d s");
        resetAndStartTimer();
        runOCaml();
        stopAndReportTimer("Time required to run krun OCaml: %d s");
        return parseOCamlOutput();
    }

    private void generateOCaml(K k, Optional<Integer> depth) {
        String ocaml = converter.convert(k, depth.orElse(-1));
        FileUtil.save(pgmSourceFile, ocaml);
    }

    private void compileOCaml() {
        try {
            Process p = startCompileProcess();

            try {
                int exit = p.waitFor();
                if(exit != 0) { compileFailedError(exit); }
            } catch(InterruptedException e) {
                compileInterruptedError(e);
            }
        } catch(IOException e) {
            compileIOError(e);
        }
    }

    private void runOCaml() {
        try {
            Process p = startRuntimeProcess();

            try {
                int exit = p.waitFor();
                if(exit != 0) { runtimeFailedError(exit); }
            } catch(InterruptedException e) {
                runtimeInterruptedError(e);
            }
        } catch(IOException e) {
            runtimeIOError(e);
        }
    }

    private K parseOCamlOutput() {
        String output = FileUtil.load(runtimeOutFile);
        Module kseqSymbolic = def.getParsedDefinition().getModule("KSEQ-SYMBOLIC").get();
        BiFunction<String, Source, K> parser = def.getParser(kseqSymbolic, Sorts.K(), kem);
        return parser.apply(output, ocamlSrc);
    }

    private Process startRuntimeProcess() throws IOException {
        return startProcess(processBuilder,
                            runtimeDirectory,
                            runtimeErrFile,
                            runtimeOutFile,
                            getRuntimeCommandLine());
    }

    private Process startCompileProcess() throws IOException {
        return startProcess(processBuilder,
                            compileDirectory,
                            compileErrFile,
                            compileOutFile,
                            getCompileCommandLine());
    }

    private String[] getCompileCommandLine() {
        int pbListLength = ocamlCmd.length + 10; // padding
        List<String> pbList = Lists.newArrayListWithCapacity(pbListLength);

        pbList = FuncUtil.addMany(pbList, ocamlCmd);
        pbList.add("-I");
        pbList.add(kompileDirectory.getAbsolutePath());
        pbList.add(kompileDefFile.getAbsolutePath());
        pbList.add(pgmSourceFileName);

        return pbList.toArray(new String[pbList.size()]);
    }

    private String[] getRuntimeCommandLine() {
        return new String[]{ binaryOutputFileName };
    }

    private void nonExecutionModuleError() {
        throw kemCriticalErrorF("Invalid module specified for rewriting.\n" +
                                "Functional backend only supports rewriting\n" +
                                "over the definition's main module.");
    }

    private void compileFailedError(int exitCode) {
        errprintfln(FileUtil.load(compileErrFile));
        throw kemCriticalErrorF("Failed to compile program to OCaml.\n" +
                                "See output for error information.\n" +
                                "OCaml exit code: %d\n", exitCode);
    }

    private void runtimeFailedError(int exitCode) {
        errprintfln(FileUtil.load(runtimeErrFile));
        throw kemCriticalErrorF("Failed to execute program in OCaml.\n" +
                                "Rerun with --debug and examine the\n" +
                                "temporary directory for information\n" +
                                "Program exit code: %d\n", exitCode);
    }

    private void compileInterruptedError(InterruptedException e) {
        Thread.currentThread().interrupt();
        throw kemCriticalErrorF(e, "OCaml compile process interrupted.");
    }

    private void runtimeInterruptedError(InterruptedException e) {
        Thread.currentThread().interrupt();
        throw kemCriticalErrorF(e, "Generated OCaml code interrupted.");
    }

    private void compileIOError(IOException e) {
        throw kemCriticalErrorF(e, "Failed to run OCaml compiler: %s", e.getMessage());
    }

    private void runtimeIOError(IOException e) {
        throw kemCriticalErrorF(e, "Failed to run generated OCaml program: %s", e.getMessage());
    }

    private void resetAndStartTimer() {
        timer.reset();
        timer.start();
    }

    private void stopAndReportTimer(String format) {
        timer.stop();
        outprintfln(format, timer.elapsed(TimeUnit.SECONDS));
    }
}
