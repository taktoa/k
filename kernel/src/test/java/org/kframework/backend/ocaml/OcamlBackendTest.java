// Copyright (c) 2014-2015 K Team. All Rights Reserved.
package org.kframework.backend.ocaml;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Comparator;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.SetMultimap;
import com.google.inject.Provider;
import org.kframework.attributes.Source;
import org.kframework.builtin.BooleanUtils;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.definition.ModuleTransformer;
import org.kframework.definition.Production;
import org.kframework.definition.Rule;
import org.kframework.kil.Attribute;
import org.kframework.kil.Definition;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.KompileOptions;
import org.kframework.kore.InjectedKLabel;
import org.kframework.kore.K;
import org.kframework.kore.KApply;
import org.kframework.kore.KLabel;
import org.kframework.kore.KRewrite;
import org.kframework.kore.KSequence;
import org.kframework.kore.KToken;
import org.kframework.kore.KVariable;
import org.kframework.kore.Sort;
import org.kframework.kore.ToKast;
import org.kframework.kore.compile.ConvertDataStructureToLookup;
import org.kframework.kore.compile.GenerateSortPredicates;
import org.kframework.kore.compile.LiftToKSequence;
import org.kframework.kore.compile.RewriteToTop;
import org.kframework.kore.compile.VisitKORE;
//import org.kframework.backend.java.symbolic.JavaSymbolicBackend;
import org.kframework.backend.java.indexing.RuleIndex;
import org.kframework.krun.KRun;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.BinaryLoader;
import org.kframework.utils.StringUtil;
import org.kframework.utils.Stopwatch;
import org.kframework.utils.algorithms.SCCTarjan;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import scala.Function1;

import java.io.File;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static org.kframework.Collections.*;
import static org.kframework.kore.KORE.*;
import static scala.compat.java8.JFunction.*;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.kframework.backend.ocaml.compile.DefinitionToOcaml;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import com.google.common.collect.Maps;

@RunWith(MockitoJUnitRunner.class)
public class OcamlBackendTest {

    // TODO: get this working
    private CompiledDefinition kompile(KExceptionManager kem, File kdef) {
        KompileOptions kopts = new KompileOptions();
        Stopwatch sw = null;
        BinaryLoader loader = null;
        Path tmpdir = Files.createTempDirectory("k-ocaml-tmp-", null);
        Path defdir = Files.createTempDirectory("k-ocaml-def-", null);
        FileUtil futil = new FileUtil(tmpdir, defdir, workdir, kompdir, null, null);
        Provider<DefinitionLoader> dfl = new DefinitionLoader(sw, loader, kem, outer, true, futil, sdf);
        Context ctx = new Context();
        String defModule = "IMP";
        
        Definition javaDef = dfl.loadDefinition(kdef, defModule, ctx);
        Backend backend = null;
        CompilerSteps<Definition> steps = backend.getCompilationSteps();
        String step = backend.getDefaultStep();

        try {
            javaDef = steps.compile(javaDef, step);
        } catch(CompilerStepDone e) {
            javaDef = (Definition) e.getResult();
        }
        
        // loader.saveOrDie(files.resolveKompiled("definition-concrete.bin"), javaDef);

        // loader.saveOrDie(files.resolveKompiled("configuration.bin"),
        //         MetaK.getConfiguration(javaDef, context));

        // b.run(javaDef);
        
        // yeah yeah refactor these names later
        Object pd  = null; // parsed definition
        Object kd  = null; // kompiled definition
        Object pss = null; // program start symbol
        Object tci = null; // top cell initializer

        return CompiledDefinition(kopts, pd, kd, pss, tci);
    }

    // The test program
    private K testProgram(BiFunction<String, Source, K> programParser) {
        String tpgm = "int s, n, .Ids; n = 10; while(0<=n) { s = s + n; n = n + -1; }";
        String tsrc = "generated by DefinitionToOcaml";
        return programParser.apply(tpgm, Source.apply(tsrc));
    } 

    
    // This should just print out the OCaml corresponding to the test program
    @Test
    public void testOcaml() {
        KExceptionManager kem = new KExceptionManager(new GlobalOptions());
        File kfile = "kore_imp_tiny.k";
        CompiledDefinition def = kompile(kem, new File(kfile));

        K program = testProgram(def.getProgramParser(kem));

        DefinitionToOcaml convert = new DefinitionToOcaml();
        String ocaml = convert.convert(def);
        System.out.println(ocaml);
        String pgm = convert.convert(new KRun(kem, FileUtil.testFileUtil()).plugConfigVars(def, Collections.singletonMap(KToken(Sorts.KConfigVar(), "$PGM"), program)));
        System.out.println(pgm);

        assertEquals(true, true); // TODO: replace with actual unit test.
    }
}
