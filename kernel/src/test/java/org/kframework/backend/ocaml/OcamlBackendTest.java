// Copyright (c) 2014-2015 K Team. All Rights Reserved.
package org.kframework.backend.ocaml;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Comparator;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.SetMultimap;
import com.google.inject.Provider;
import com.google.inject.util.Providers;
import org.kframework.attributes.Source;
import org.kframework.builtin.BooleanUtils;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.definition.ModuleTransformer;
import org.kframework.definition.Production;
import org.kframework.definition.Rule;
import org.kframework.kil.Attribute;
import org.kframework.kil.Definition;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.KompileOptions;
import org.kframework.kompile.Kompile;
import org.kframework.kore.InjectedKLabel;
import org.kframework.kore.K;
import org.kframework.kore.KApply;
import org.kframework.kore.KLabel;
import org.kframework.kore.KRewrite;
import org.kframework.kore.KSequence;
import org.kframework.kore.KToken;
import org.kframework.kore.KVariable;
import org.kframework.kore.Sort;
import org.kframework.kore.ToKast;
import org.kframework.kore.compile.ConvertDataStructureToLookup;
import org.kframework.kore.compile.GenerateSortPredicates;
import org.kframework.kore.compile.LiftToKSequence;
import org.kframework.kore.compile.RewriteToTop;
import org.kframework.kore.compile.VisitKORE;
import org.kframework.krun.KRun;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.BinaryLoader;
import org.kframework.utils.StringUtil;
import org.kframework.utils.Stopwatch;
import org.kframework.utils.algorithms.SCCTarjan;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import scala.Function1;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static org.kframework.Collections.*;
import static org.kframework.kore.KORE.*;
import static scala.compat.java8.JFunction.*;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.kframework.backend.ocaml.compile.DefinitionToOcaml;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import com.google.common.collect.Maps;

@RunWith(MockitoJUnitRunner.class)
public class OcamlBackendTest {

    private GlobalOptions gopts;
    private FileUtil futil;
    private File kfile;
    private CompiledDefinition cdef;
    private KExceptionManager kem;
    
    // FIXME
    private void tempFileUtil(File kdef) throws IOException {
        Path p = Files.createTempDirectory("k-ocaml-tmp-");
        File f = p.toFile();
        kfile = new File(p.toString() + File.separator + kdef.getName());
        System.out.format("Source: %s\nDest: %s\n", kdef.toString(), kfile.toString());
        Files.copy(kdef.toPath(), kfile.toPath());
        kfile.deleteOnExit();
        Provider<File> pf = Providers.of(f);
        futil = new FileUtil(f, pf, f, pf, gopts, System.getenv());
    }
    
    // TODO: get this working
    private void kompile() {
        KompileOptions kopts = new KompileOptions();

        String definitionFilename = kfile.getName();
//        String mainModuleName = futil.getMainModule(definitionFilename);
//        String programModuleName = mainModuleName; // FIXME
        String mainModuleName    = "TEST";          // FIXME
        String programModuleName = "TEST"; // FIXME

        System.out.format("DefFN: %s\n", definitionFilename);
        System.out.format("MnMdN: %s\n", mainModuleName);
        System.out.format("PgmMN: %s\n", programModuleName);
        
        Kompile komp = new Kompile(kopts, futil, kem, false);
        
        cdef = komp.run(kfile, mainModuleName, programModuleName, Sorts.K());
    }

    // The test program
    private K testProgram() {
        //        String tpgm = "int s, n; n = 10; while(0 <= n) { s = s + n; n = n + -1; }";
        String tpgm = "int n, .Ids; n = 10; while(0 <= n) { n = n + -1; }";
        String tsrc = "generated by DefinitionToOcaml";
        return cdef.getProgramParser(kem).apply(tpgm, Source.apply(tsrc));
    } 


    private void testInit() throws IOException {
        gopts = new GlobalOptions();
        kem = new KExceptionManager(gopts);
        tempFileUtil(new File("src/test/resources/kore_imp_tiny.k"));
        kompile();
    }
    
    // This should just print out the OCaml corresponding to the test program
    @Test
    public void testOcaml() throws IOException {
        testInit();
        K program = testProgram();
        System.out.println(program.toString());
        Map initMap = Collections.singletonMap(KToken(Sorts.KConfigVar(), "$PGM"), program);
        K runpgm = (new KRun(kem, futil)).plugConfigVars(cdef, initMap);

        DefinitionToOcaml conv = new DefinitionToOcaml();
        String ocaml = conv.convert(cdef);
        System.out.println(ocaml);
        String pgm = conv.convert(runpgm);
        System.out.println(pgm);

        assertEquals(true, true); // TODO: replace with actual unit test.
        
    }
}
